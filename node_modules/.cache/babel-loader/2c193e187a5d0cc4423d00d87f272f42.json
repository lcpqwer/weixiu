{"remainingRequest":"/Users/szt/Documents/szt/iview-admin/node_modules/babel-loader/lib/index.js!/Users/szt/Documents/szt/iview-admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/szt/Documents/szt/iview-admin/src/components/split-pane/split.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/szt/Documents/szt/iview-admin/src/components/split-pane/split.vue","mtime":1539597142000},{"path":"/Users/szt/Documents/szt/iview-admin/.babelrc","mtime":1539597141000},{"path":"/Users/szt/Documents/szt/iview-admin/node_modules/cache-loader/dist/cjs.js","mtime":1539597352000},{"path":"/Users/szt/Documents/szt/iview-admin/node_modules/babel-loader/lib/index.js","mtime":1529635966000},{"path":"/Users/szt/Documents/szt/iview-admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { oneOf, on, off } from '@/libs/tools';\nimport Trigger from './trigger.vue';\nexport default {\n  name: 'SplitPane',\n  components: {\n    Trigger: Trigger\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0.5\n    },\n    mode: {\n      validator: function validator(value) {\n        return oneOf(value, ['horizontal', 'vertical']);\n      },\n      default: 'horizontal'\n    },\n    min: {\n      type: [Number, String],\n      default: '40px'\n    },\n    max: {\n      type: [Number, String],\n      default: '40px'\n    }\n  },\n\n  /**\n   * Events\n   * @on-move-start\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\n   * @on-move-end\n   */\n  data: function data() {\n    return {\n      prefix: 'ivu-split',\n      offset: 0,\n      oldOffset: 0,\n      isMoving: false\n    };\n  },\n  computed: {\n    wrapperClasses: function wrapperClasses() {\n      return [\"\".concat(this.prefix, \"-wrapper\"), this.isMoving ? 'no-select' : ''];\n    },\n    isHorizontal: function isHorizontal() {\n      return this.mode === 'horizontal';\n    },\n    anotherOffset: function anotherOffset() {\n      return 100 - this.offset;\n    },\n    valueIsPx: function valueIsPx() {\n      return typeof this.value === 'string';\n    },\n    offsetSize: function offsetSize() {\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight';\n    },\n    computedMin: function computedMin() {\n      return this.getComputedThresholdValue('min');\n    },\n    computedMax: function computedMax() {\n      return this.getComputedThresholdValue('max');\n    }\n  },\n  methods: {\n    px2percent: function px2percent(numerator, denominator) {\n      return parseFloat(numerator) / parseFloat(denominator);\n    },\n    getComputedThresholdValue: function getComputedThresholdValue(type) {\n      var size = this.$refs.outerWrapper[this.offsetSize];\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type];else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type];\n    },\n    getMin: function getMin(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.min(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.min(value1, value2);\n    },\n    getMax: function getMax(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.max(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.max(value1, value2);\n    },\n    getAnotherOffset: function getAnotherOffset(value) {\n      var res = 0;\n      if (this.valueIsPx) res = \"\".concat(this.$refs.outerWrapper[this.offsetSize] - parseFloat(value), \"px\");else res = 1 - value;\n      return res;\n    },\n    handleMove: function handleMove(e) {\n      var pageOffset = this.isHorizontal ? e.pageX : e.pageY;\n      var offset = pageOffset - this.initOffset;\n      var outerWidth = this.$refs.outerWrapper[this.offsetSize];\n      var value = this.valueIsPx ? \"\".concat(parseFloat(this.oldOffset) + offset, \"px\") : this.px2percent(outerWidth * this.oldOffset + offset, outerWidth);\n      var anotherValue = this.getAnotherOffset(value);\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin);\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax));\n      e.atMin = this.value === this.computedMin;\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5);\n      this.$emit('input', value);\n      this.$emit('on-moving', e);\n    },\n    handleUp: function handleUp() {\n      this.isMoving = false;\n      off(document, 'mousemove', this.handleMove);\n      off(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-end');\n    },\n    handleMousedown: function handleMousedown(e) {\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY;\n      this.oldOffset = this.value;\n      this.isMoving = true;\n      on(document, 'mousemove', this.handleMove);\n      on(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-start');\n    }\n  },\n  watch: {\n    value: function value() {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100;\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      _this.offset = (_this.valueIsPx ? _this.px2percent(_this.value, _this.$refs.outerWrapper[_this.offsetSize]) : _this.value) * 10000 / 100;\n    });\n  }\n};",{"version":3,"sources":["split.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div ref=\"outerWrapper\" :class=\"wrapperClasses\">\n    <div v-if=\"isHorizontal\" :class=\"`${prefix}-horizontal`\">\n      <div :style=\"{right: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'left-pane']\"><slot name=\"left\"/></div>\n      <div :class=\"`${prefix}-trigger-con`\" :style=\"{left: `${offset}%`}\" @mousedown=\"handleMousedown\">\n        <slot name=\"trigger\">\n          <trigger mode=\"vertical\"/>\n        </slot>\n      </div>\n      <div :style=\"{left: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'right-pane']\"><slot name=\"right\"/></div>\n    </div>\n    <div v-else :class=\"`${prefix}-vertical`\">\n      <div :style=\"{bottom: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'top-pane']\"><slot name=\"top\"/></div>\n     <div :class=\"`${prefix}-trigger-con`\" :style=\"{top: `${offset}%`}\" @mousedown=\"handleMousedown\">\n        <slot name=\"trigger\">\n          <trigger mode=\"horizontal\"/>\n        </slot>\n      </div>\n      <div :style=\"{top: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'bottom-pane']\"><slot name=\"bottom\"/></div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { oneOf, on, off } from '@/libs/tools'\nimport Trigger from './trigger.vue'\nexport default {\n  name: 'SplitPane',\n  components: {\n    Trigger\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0.5\n    },\n    mode: {\n      validator (value) {\n        return oneOf(value, ['horizontal', 'vertical'])\n      },\n      default: 'horizontal'\n    },\n    min: {\n      type: [Number, String],\n      default: '40px'\n    },\n    max: {\n      type: [Number, String],\n      default: '40px'\n    }\n  },\n  /**\n   * Events\n   * @on-move-start\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\n   * @on-move-end\n   */\n  data () {\n    return {\n      prefix: 'ivu-split',\n      offset: 0,\n      oldOffset: 0,\n      isMoving: false\n    }\n  },\n  computed: {\n    wrapperClasses () {\n      return [\n        `${this.prefix}-wrapper`,\n        this.isMoving ? 'no-select' : ''\n      ]\n    },\n    isHorizontal () {\n      return this.mode === 'horizontal'\n    },\n    anotherOffset () {\n      return 100 - this.offset\n    },\n    valueIsPx () {\n      return typeof this.value === 'string'\n    },\n    offsetSize () {\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight'\n    },\n    computedMin () {\n      return this.getComputedThresholdValue('min')\n    },\n    computedMax () {\n      return this.getComputedThresholdValue('max')\n    }\n  },\n  methods: {\n    px2percent (numerator, denominator) {\n      return parseFloat(numerator) / parseFloat(denominator)\n    },\n    getComputedThresholdValue (type) {\n      let size = this.$refs.outerWrapper[this.offsetSize]\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type]\n      else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type]\n    },\n    getMin (value1, value2) {\n      if (this.valueIsPx) return `${Math.min(parseFloat(value1), parseFloat(value2))}px`\n      else return Math.min(value1, value2)\n    },\n    getMax (value1, value2) {\n      if (this.valueIsPx) return `${Math.max(parseFloat(value1), parseFloat(value2))}px`\n      else return Math.max(value1, value2)\n    },\n    getAnotherOffset (value) {\n      let res = 0\n      if (this.valueIsPx) res = `${this.$refs.outerWrapper[this.offsetSize] - parseFloat(value)}px`\n      else res = 1 - value\n      return res\n    },\n    handleMove (e) {\n      let pageOffset = this.isHorizontal ? e.pageX : e.pageY\n      let offset = pageOffset - this.initOffset\n      let outerWidth = this.$refs.outerWrapper[this.offsetSize]\n      let value = this.valueIsPx ? `${parseFloat(this.oldOffset) + offset}px` : (this.px2percent(outerWidth * this.oldOffset + offset, outerWidth))\n      let anotherValue = this.getAnotherOffset(value)\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin)\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax))\n      e.atMin = this.value === this.computedMin\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5)\n      this.$emit('input', value)\n      this.$emit('on-moving', e)\n    },\n    handleUp () {\n      this.isMoving = false\n      off(document, 'mousemove', this.handleMove)\n      off(document, 'mouseup', this.handleUp)\n      this.$emit('on-move-end')\n    },\n    handleMousedown (e) {\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY\n      this.oldOffset = this.value\n      this.isMoving = true\n      on(document, 'mousemove', this.handleMove)\n      on(document, 'mouseup', this.handleUp)\n      this.$emit('on-move-start')\n    }\n  },\n  watch: {\n    value () {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\n    }\n  },\n  mounted () {\n    this.$nextTick(() => {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\n    })\n  }\n}\n</script>\n\n<style lang=\"less\">\n@import './index.less';\n</style>\n"],"sourceRoot":"src/components/split-pane"}]}